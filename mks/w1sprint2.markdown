## Data Modeling and Classes

There are 4 different instantiation patterns in JavaScript. Here is a good [spreadsheet](http://www.ryanatkinson.io/javascript-instantiation-patterns/) outlining each. I'll walk through all of them.

###The functional pattern

- a simple "maker" pattern
- does not use `new`, `this`, or `prototype` chains
- Generate, assign properties, and define methods within a function.
- There are no methods delegated to fallback object.

```
var House = function(color) {
  
  //Generate Object
  var obj = {} 

  //Assign properties
  obj.color = color;
  obj.door = 'open';

  //Explicitly define methods
  obj.openDoor = function() {
  obj.dorr = 'open;'
  }

 //return Object
  return obj;
}

//instantiate
var house = House('red');
```

- **Pros**: very clear object construction.
- **Cons**: results in duplicate methods.

###The functional-shared pattern

- a simple "maker" pattern with shared methods
- does not use `new` or `prototype` chains

```
var House = function(color) {
  
  //Generate Object
  var obj = {} 

  //Assign properties
  obj.color = color;
  obj.door = 'open';

  //Explicitly define methods
  obj.openDoor = houseMethod;

 //return Object
  return obj;
}

//shared method
var houseMethod = function() {
  this.door = 'open;'
  }

//instantiate
var house = House('red');
```

- **Pros**: Methods shared between objects
- **Cons**: Setting a pointer to a method is less efficient than delegating a fallback.

###The prototypal pattern

- uses `Object.create`
- does not use `new`

```
var House = function(color) {
  
  //Generate Object
  var obj = Object.create(House.prototype);

  //Assign properties
  obj.color = color;
  obj.door = 'open';

 //return Object
  return obj;
}

//House.prototype = {} is automatically generated by the interpreter.

//add methods to delegated fallback object
House.prototype.openDoor = function() {
  this.door = 'open';
}

//instantiate
var house = House('red');
```

- **Pros**: instances delegate fallback to House.prototype methods
- **Cons**: uses unnecessary lines of code compared to psuedoclassical


###The pseudoclassical pattern

- creates instances with the keyword new
- does not declare the instance explicitly
- does not return the instance explicitly

```
var House = function(color) {
  
  //Generate Object
  //interpreter does this for you!
  //var this = Object.create(House.prototype);

  //Assign properties
  obj.color = color;
  obj.door = 'open';

 //do not need to return object
 //automatically generated by interpreter
 //return this;

}

//House.prototype = {} is automatically generated by the interpreter.

//add methods to delegated fallback object
House.prototype.openDoor = function() {
  this.door = 'open';
}

//instantiate
var house = new House('red');
```

- **Pros**: much more concise code, clear `this` binding, and delegates to House.prototype methods
- **Cons**: interpreter magic happens and makes object construction unclear

## Style

If using Sublime:

```
{

  "tab_size": 2,
  "translate_tabs_to_spaces": true
}
```





