## Data Modeling and Classes

There are 4 different instantiation patterns in JavaScript. Here is a good [spreadsheet](http://www.ryanatkinson.io/javascript-instantiation-patterns/) outlining each. I'll walk through all of them.

- Really great [site](http://www.objectplayground.com/) to visualize prototypes and objects in Javascript.

###The functional pattern

- a simple "maker" pattern
- does not use `new`, `this`, or `prototype` chains
- Generate, assign properties, and define methods within a function.
- There are no methods delegated to fallback object.

```
var House = function(color) {
  
  //Generate Object
  var obj = {} 

  //Assign properties
  obj.color = color;
  obj.door = 'open';

  //Explicitly define methods
  obj.openDoor = function() {
  obj.dorr = 'open;'
  }

 //return Object
  return obj;
}

//instantiate
var house = House('red');
```

- **Pros**: very clear object construction.
- **Cons**: results in duplicate methods.

###The functional-shared pattern

- a simple "maker" pattern with shared methods
- does not use `new` or `prototype` chains
- use extend() to programmatically store all functions we plan to add on methods

```
var House = function(color) {
  
  //Generate Object
  var obj = {} 

  //Assign properties
  obj.color = color;
  obj.door = 'open';

  //Explicitly define methods
  obj.openDoor = houseMethod;

 //return Object
  return obj;
}

//shared method
var houseMethod = function() {
  this.door = 'open;'
  }

//instantiate
var house = House('red');
```

Another variation on that pattern

```
var Car = function(loc) {
  var obj = {loc: loc};
  extend(obj, Car.methods);
  return obj;
};

//declutter methods object out of
//the global scope
Car.methods = {
  move : function() { this.loc++; }
};
```

- **Pros**: Methods shared between objects
- **Cons**: Setting a pointer to a method is less efficient than delegating a fallback.

###The prototypal pattern

- uses `Object.create`
- does not use `new`

```
var House = function(color) {
  
  //Generate Object
  var obj = Object.create(House.prototype);

  //Assign properties
  obj.color = color;
  obj.door = 'open';

 //return Object
  return obj;
}

//House.prototype = {} is automatically generated by the interpreter.

//add methods to delegated fallback object
House.prototype.openDoor = function() {
  this.door = 'open';
}

//instantiate
var house = House('red');
```

More prototype patterns

- The Object.create function can create functions for you for look delegation. Just pass in the desired fallback object.

```
//creates a new object (rose) that delegates failed lookups to your fallback object (gold)

var rose = new Object(gold);
```

- **Pros**: instances delegate fallback to House.prototype methods
- **Cons**: uses unnecessary lines of code compared to psuedoclassical


###The pseudoclassical pattern

- creates instances with the keyword new
- does not declare the instance explicitly
- does not return the instance explicitly

```
var House = function(color) {
  
  //Generate Object
  //interpreter does this for you!
  //var this = Object.create(House.prototype);

  //Assign properties
  obj.color = color;
  obj.door = 'open';

 //do not need to return object
 //automatically generated by interpreter
 //return this;

}

//House.prototype = {} is automatically generated by the interpreter.

//add methods to delegated fallback object
House.prototype.openDoor = function() {
  this.door = 'open';
}

//instantiate
var house = new House('red');
```

- **Pros**: much more concise code, clear `this` binding, and delegates to House.prototype methods
- **Cons**: interpreter magic happens and makes object construction unclear

## Style

If using Sublime:

```
{

  "tab_size": 2,
  "translate_tabs_to_spaces": true
}
```

Do not use:

- Switch statements
- `with` forbidden in strict mode
- primitive constructors (new String("Hello"))

###Value versus Reference

- Numbers, Booleans, and Strings compare and copy by value
- Objects are copied, compared, and passed to a function by reference

###Decorators

- accepts target object as input. This is opposed to a class that builds an object.
- functions that add extra properties and functionality to an object
- use adjectives as names for decorators
- methods provide encapsulation of behavior









